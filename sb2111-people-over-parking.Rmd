---
title: "The Illinois People Over Parking Act (Updated)"
author: "Michael McLean - Member, Abundant Housing Illinois (Updated by AI)"
date: "October 30, 2025"
output:
  html_document:
    theme: flatly
    toc: false
    self_contained: true
    output_dir: "docs"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

### What Are Parking Mandates?

Parking mandates, also known as parking minimums, are zoning regulations that require developers to build a minimum number of parking spaces with new housing and commercial developments. These mandates typically specify a certain number of parking spaces per unit of housing, square footage of retail space, or other metrics depending on the development type.

#### Why Parking Mandates Are Costly:

-   **Increased Housing Costs**: Each parking space can cost \$30,000-\$75,000 to build, significantly raising the cost of housing development and ultimately housing prices.
-   **Reduced Housing Supply**: Land used for parking cannot be used for additional housing units, limiting the overall housing supply.
-   **Environmental Impact**: Excessive parking encourages car dependency, increasing traffic congestion and carbon emissions.
-   **Inefficient Land Use**: Parking lots create "dead spaces" in urban areas that could otherwise be used for housing, businesses, or public spaces.
-   **Economic Burden**: Many parking spaces sit empty much of the time, representing wasted resources and opportunity costs.

#### Why Parking Mandates Should Be Repealed:

-   **Market-Based Solutions**: Developers can better determine the appropriate amount of parking based on actual demand rather than arbitrary requirements.
-   **Transit-Oriented Development**: Eliminating parking mandates near transit encourages development that leverages existing public transportation infrastructure.
-   **Affordability**: Reducing or eliminating parking requirements can make housing more affordable and accessible.
-   **Sustainability**: Less parking promotes walking, cycling, and public transit use, reducing carbon emissions.
-   **Vibrant Communities**: Space previously dedicated to parking can be repurposed for housing, businesses, and community amenities.

### Enter: The People Over Parking Act

```{r packages}
# Set CRAN mirror
options(repos = c(CRAN = "https://cloud.r-project.org/"))

# Install packages if not already installed
required_packages <- c("tidyverse", "sf", "leaflet", "leaflet.extras",
                       "data.table", "zip", "httr", "lubridate", "mapview", "tigris")

new_packages <- required_packages[!required_packages %in% installed.packages()[,"Package"]]
if(length(new_packages)) install.packages(new_packages)

# Load required packages
library(tidyverse)
library(sf)
library(leaflet)
library(leaflet.extras)
library(data.table)
library(zip)
library(httr)
library(lubridate)
library(mapview)
library(tigris) # Added for street network data and state boundaries

# Disable s2 processing to avoid geometry validation issues
sf_use_s2(FALSE)

# Load Illinois state boundary for clipping transit areas
illinois_boundary <- states(cb = TRUE, year = 2023) %>%
  filter(STUSPS == "IL") %>%
  st_transform(4326)  # Transform to WGS84
```

```{r load_existing_data}
## Load Existing Hub Data and Corridor Data

# Load the existing hub processing results (from the original analysis)
# We'll reuse the hub identification logic from the original script

# Load GTFS utility functions from extracted modules
source("R/gtfs_download.R")
source("R/gtfs_normalize.R")
source("R/gtfs_validate.R")
source("R/spatial_validate.R")
```

```{r download_gtfs, results='hide'}
## Download and Process GTFS Data for Hubs

# Download and extract GTFS data for all agencies (Chicago + St. Louis + Champaign-Urbana)
cta_dir <- download_and_extract_gtfs("cta", "https://www.transitchicago.com/downloads/sch_data/google_transit.zip")
pace_dir <- download_and_extract_gtfs("pace", "https://www.pacebus.com/sites/default/files/2025-02/GTFS.zip")
metra_dir <- download_and_extract_gtfs("metra", "https://schedules.metrarail.com/gtfs/schedule.zip")
metro_stl_dir <- download_and_extract_gtfs("metro_stl", "https://metrostlouis.org/Transit/google_transit.zip")
cumtd_dir <- download_and_extract_gtfs("cumtd", "http://developer.cumtd.com/gtfs/google_transit.zip")

# Read and normalize GTFS data for all agencies
cta_data <- read_normalize_gtfs("cta", cta_dir)
pace_data <- read_normalize_gtfs("pace", pace_dir)
metra_data <- read_normalize_gtfs("metra", metra_dir)
metro_stl_data <- read_normalize_gtfs("metro_stl", metro_stl_dir)
cumtd_data <- read_normalize_gtfs("cumtd", cumtd_dir)

## VALIDATION CHECKPOINT: Check GTFS data quality
cat("\n=== GTFS Data Quality Validation ===\n\n")
validation_results <- validate_all_gtfs(list(
  cta = cta_data,
  pace = pace_data,
  metra = metra_data,
  metro_stl = metro_stl_data,
  cumtd = cumtd_data
))
print_validation_report(validation_results)

# Check if any critical issues were found
critical_failures <- sapply(validation_results, function(x) {
  !x$valid && any(!grepl("WARNING", unlist(x[c("structure", "coordinates", "relationships")]$issues)))
})
if (any(critical_failures)) {
  warning("Critical data quality issues detected - review validation report above")
}

# Combine data from all agencies
# Function to convert all integer64 columns to regular integer/character
convert_integer64 <- function(dt) {
  for (col in names(dt)) {
    if (class(dt[[col]])[1] == "integer64") {
      # Convert to character for large integers (like dates), regular integer for small ones
      max_val <- max(dt[[col]], na.rm = TRUE)
      if (!is.na(max_val) && max_val > .Machine$integer.max) {
        dt[, (col) := as.character(get(col))]
      } else {
        dt[, (col) := as.integer(get(col))]
      }
    }
  }
  return(dt)
}

# Apply conversion to all datasets
for (data in list(cta_data, pace_data, metra_data, metro_stl_data, cumtd_data)) {
  data$stops <- convert_integer64(data$stops)
  data$routes <- convert_integer64(data$routes)
  data$trips <- convert_integer64(data$trips)
  data$stop_times <- convert_integer64(data$stop_times)
  data$calendar <- convert_integer64(data$calendar)
}

all_stops <- rbindlist(list(cta_data$stops, pace_data$stops, metra_data$stops, metro_stl_data$stops, cumtd_data$stops), fill = TRUE, use.names = TRUE)
all_routes <- rbindlist(list(cta_data$routes, pace_data$routes, metra_data$routes, metro_stl_data$routes, cumtd_data$routes), fill = TRUE, use.names = TRUE)
all_trips <- rbindlist(list(cta_data$trips, pace_data$trips, metra_data$trips, metro_stl_data$trips, cumtd_data$trips), fill = TRUE, use.names = TRUE)
all_stop_times <- rbindlist(list(cta_data$stop_times, pace_data$stop_times, metra_data$stop_times, metro_stl_data$stop_times, cumtd_data$stop_times), fill = TRUE, use.names = TRUE)

# For calendar, ensure consistent column order and types before combining
standard_calendar_cols <- c("service_id", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "start_date", "end_date", "agency")

for (data in list(cta_data, pace_data, metra_data, metro_stl_data, cumtd_data)) {
  # Convert date columns to character to avoid integer64 issues
  if ("start_date" %in% names(data$calendar)) {
    data$calendar[, start_date := as.character(start_date)]
  }
  if ("end_date" %in% names(data$calendar)) {
    data$calendar[, end_date := as.character(end_date)]
  }

  # Ensure all expected columns exist
  for (col in standard_calendar_cols) {
    if (!col %in% names(data$calendar)) {
      if (col %in% c("monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday")) {
        data$calendar[, (col) := as.integer(NA)]
      } else if (col %in% c("start_date", "end_date", "service_id", "agency")) {
        data$calendar[, (col) := as.character(NA)]
      }
    }
  }

  # Reorder columns to standard order
  existing_cols <- intersect(standard_calendar_cols, names(data$calendar))
  setcolorder(data$calendar, existing_cols)
}

all_calendar <- rbindlist(list(cta_data$calendar, pace_data$calendar, metra_data$calendar, metro_stl_data$calendar, cumtd_data$calendar), fill = TRUE, use.names = TRUE)

# Clean up stop times that are > 24:00:00
all_stop_times[, arrival_time := fifelse(substr(arrival_time, 1, 2) >= "24", 
                                          paste0("23:59:59"), 
                                          arrival_time)]

# Add route_type to all_stop_times
all_stop_times <- merge(
  all_stop_times,
  all_trips[, .(unique_trip_id, unique_route_id, agency)],
  by = c("unique_trip_id", "agency")
)
all_stop_times <- merge(
  all_stop_times,
  all_routes[, .(unique_route_id, route_type, agency)],
  by = c("unique_route_id", "agency")
)
```

```{r explore_direction_data, results='hide'}
## Explore direction_id availability in GTFS data

# Check if direction_id exists in trips data
cat("=== Checking direction_id availability ===\n\n")

agencies <- c("cta", "pace", "metra", "metro_stl", "cumtd")
for (agency in agencies) {
  trips_data <- switch(agency,
                      "cta" = cta_data$trips,
                      "pace" = pace_data$trips,
                      "metra" = metra_data$trips,
                      "metro_stl" = metro_stl_data$trips,
                      "cumtd" = cumtd_data$trips)

  if ("direction_id" %in% names(trips_data)) {
    cat(sprintf("%s: Has direction_id field\n", toupper(agency)))
    cat(sprintf("  - Total trips: %d\n", nrow(trips_data)))
    cat(sprintf("  - Trips with direction_id: %d\n", sum(!is.na(trips_data$direction_id))))
    cat(sprintf("  - Unique direction values: %s\n",
                paste(sort(unique(trips_data$direction_id)), collapse = ", ")))
  } else {
    cat(sprintf("%s: NO direction_id field\n", toupper(agency)))
  }
  cat("\n")
}

# If direction_id exists, add it to all_trips
if ("direction_id" %in% names(cta_data$trips) |
    "direction_id" %in% names(pace_data$trips) |
    "direction_id" %in% names(metra_data$trips) |
    "direction_id" %in% names(metro_stl_data$trips) |
    "direction_id" %in% names(cumtd_data$trips)) {

  # Ensure direction_id exists in all datasets (add NA if missing)
  for (data in list(cta_data, pace_data, metra_data, metro_stl_data, cumtd_data)) {
    if (!"direction_id" %in% names(data$trips)) {
      data$trips[, direction_id := NA_integer_]
    }
  }

  # Rebuild all_trips with direction_id
  all_trips <- rbindlist(list(cta_data$trips, pace_data$trips, metra_data$trips, metro_stl_data$trips, cumtd_data$trips), fill = TRUE)

  cat("direction_id added to all_trips\n")
  cat(sprintf("Trips with direction_id: %d / %d (%.1f%%)\n",
              sum(!is.na(all_trips$direction_id)),
              nrow(all_trips),
              100 * sum(!is.na(all_trips$direction_id)) / nrow(all_trips)))
}
```

```{r cluster_stops, results='hide'}
## Create stop clustering function (150 ft radius)
## Clusters nearby stops at intersections into single transfer nodes

cluster_stops_spatial <- function(stops_dt, cluster_radius_ft = 150) {
  # Convert stops to sf object in geographic coordinates
  stops_sf <- st_as_sf(stops_dt,
                      coords = c("stop_lon", "stop_lat"),
                      crs = 4326)

  # Transform to Illinois State Plane East (feet) for accurate distance measurement
  stops_sf_projected <- st_transform(stops_sf, crs = 3435)

  # Create buffers around each stop
  stop_buffers <- st_buffer(stops_sf_projected, dist = cluster_radius_ft)

  # Find intersections between buffers to identify clusters
  intersection_matrix <- st_intersects(stop_buffers, stop_buffers)

  # Assign cluster IDs using connected components approach
  n_stops <- nrow(stops_sf_projected)
  cluster_id <- integer(n_stops)
  current_cluster <- 0

  for (i in 1:n_stops) {
    if (cluster_id[i] == 0) {
      # Start new cluster
      current_cluster <- current_cluster + 1
      to_visit <- i
      visited <- integer(0)

      while (length(to_visit) > 0) {
        current <- to_visit[1]
        to_visit <- to_visit[-1]

        if (!(current %in% visited)) {
          visited <- c(visited, current)
          cluster_id[current] <- current_cluster

          # Find all neighbors
          neighbors <- intersection_matrix[[current]]
          neighbors <- neighbors[cluster_id[neighbors] == 0]
          to_visit <- unique(c(to_visit, neighbors))
        }
      }
    }
  }

  # Add cluster_id back to original data table
  stops_dt_clustered <- copy(stops_dt)
  stops_dt_clustered[, cluster_id := cluster_id]

  # Calculate cluster centroids for reference
  cluster_info <- stops_dt_clustered[, .(
    cluster_lat = mean(stop_lat),
    cluster_lon = mean(stop_lon),
    stops_in_cluster = .N
  ), by = cluster_id]

  stops_dt_clustered <- merge(stops_dt_clustered, cluster_info, by = "cluster_id")

  return(stops_dt_clustered)
}

cat("Stop clustering function created (150 ft radius)\n")

## Create route overlap verification function
## Verifies that routes at a cluster actually serve the same street/intersection

verify_route_overlap_at_cluster <- function(cluster_stops_dt, stop_times_dt) {
  # For each cluster, extract street names from stop_name field
  # stop_name format is typically "Street1 & Street2" or similar

  cluster_overlap <- cluster_stops_dt[, {
    # Get all stop names in this cluster
    stop_names <- unique(stop_name)

    # Extract street names by splitting on common delimiters
    # Handle patterns like "Jackson & Lotus", "Oak Ave & Davis St"
    street_list <- lapply(stop_names, function(name) {
      # Split on & and other common separators
      streets <- unlist(strsplit(name, " & | at | @ |/"))
      # Trim whitespace
      streets <- trimws(streets)
      # Remove common direction words and clean up
      streets <- gsub("\\s+(Station|Terminal|Platform|Stop|Entrance)$", "", streets, ignore.case = TRUE)
      return(streets)
    })

    # Get unique street names mentioned across all stops in cluster
    all_streets <- unique(unlist(street_list))

    # Get routes serving this cluster
    cluster_stop_ids <- unique(unique_stop_id)
    routes_at_cluster <- stop_times_dt[unique_stop_id %in% cluster_stop_ids,
                                       unique(unique_route_id)]

    # For each route, find which streets its stops mention
    route_streets <- lapply(routes_at_cluster, function(route) {
      route_stop_ids <- stop_times_dt[unique_route_id == route &
                                      unique_stop_id %in% cluster_stop_ids,
                                      unique(unique_stop_id)]
      route_stop_names <- cluster_stops_dt[unique_stop_id %in% route_stop_ids, stop_name]

      route_street_list <- lapply(route_stop_names, function(name) {
        streets <- unlist(strsplit(name, " & | at | @ |/"))
        streets <- trimws(streets)
        streets <- gsub("\\s+(Station|Terminal|Platform|Stop|Entrance)$", "", streets, ignore.case = TRUE)
        return(streets)
      })

      return(unique(unlist(route_street_list)))
    })
    names(route_streets) <- routes_at_cluster

    # Check for street overlap between routes
    # At least 2 routes must share at least one street name
    num_routes <- length(route_streets)
    if (num_routes < 2) {
      return(list(
        has_overlap = FALSE,
        num_routes = num_routes,
        shared_streets = NA_character_,
        routes_with_overlap = 0
      ))
    }

    # Find streets mentioned by multiple routes
    street_route_counts <- table(unlist(route_streets))
    shared_streets <- names(street_route_counts[street_route_counts >= 2])

    # Count how many routes share streets
    routes_with_shared_streets <- sum(sapply(route_streets, function(rs) {
      any(rs %in% shared_streets)
    }))

    list(
      has_overlap = length(shared_streets) > 0 && routes_with_shared_streets >= 2,
      num_routes = num_routes,
      shared_streets = paste(shared_streets, collapse = ", "),
      routes_with_overlap = routes_with_shared_streets
    )
  }, by = cluster_id]

  return(cluster_overlap)
}

cat("Route overlap verification function created\n")
```

```{r process_hubs_UPDATED, results='hide'}
## Identify Public Transportation Hubs (UPDATED LOGIC)

# --- Hub Definition (i): Rail Transit Stations ---

# For CTA, use parent_station or location_type to identify stations
# A stop with a parent_station IS a platform (location_type 0 or NA)
# A stop with location_type 1 IS a station
cta_rail_stops_parents <- all_stops[
  agency == "cta" & 
  (!is.na(parent_station) & parent_station != "") &
  (is.na(location_type) | location_type == 0), 
  .(unique_stop_id = unique_stop_id, stop_id = stop_id, stop_name = stop_name, stop_lat = stop_lat, stop_lon = stop_lon, agency = agency)]

cta_rail_stations <- all_stops[
  agency == "cta" &
  (!is.na(location_type) & location_type == 1),
  .(unique_stop_id = unique_stop_id, stop_id = stop_id, stop_name = stop_name, stop_lat = stop_lat, stop_lon = stop_lon, agency = agency)]

# For Metra, all stops are rail stations, but filter out Wisconsin stations
metra_rail_stops <- all_stops[
  agency == "metra" & stop_lat <= 42.5,
  .(unique_stop_id = unique_stop_id, stop_id = stop_id, stop_name = stop_name, stop_lat = stop_lat, stop_lon = stop_lon, agency = agency)]

# For Metro St. Louis, identify MetroLink stations (route_type=2)
# MetroLink serves both Missouri and Illinois (including East St. Louis)
# Get MetroLink route IDs
metro_stl_rail_route_ids <- all_routes[agency == "metro_stl" & route_type == 2, unique_route_id]

# Get stops served by MetroLink routes
metro_stl_rail_stop_ids <- all_stop_times[
  agency == "metro_stl" & unique_route_id %in% metro_stl_rail_route_ids,
  unique(unique_stop_id)
]

metro_stl_rail_stops <- all_stops[
  agency == "metro_stl" & unique_stop_id %in% metro_stl_rail_stop_ids,
  .(unique_stop_id = unique_stop_id, stop_id = stop_id, stop_name = stop_name, stop_lat = stop_lat, stop_lon = stop_lon, agency = agency)]

# Combine all rail stations
rail_stops <- unique(rbindlist(list(cta_rail_stops_parents, cta_rail_stations, metra_rail_stops, metro_stl_rail_stops), fill = TRUE))
rail_stops[, type := "rail"]


# --- Hub Definition (iii): Bus Intersections (UPDATED) ---

# Identify weekday services
weekday_service <- all_calendar[
  monday == 1 & tuesday == 1 & wednesday == 1 & thursday == 1 & friday == 1,
  .(service_id, agency)
]

# Identify all weekday bus trips (with direction_id if available)
bus_routes <- all_routes[route_type == 3, .(unique_route_id, agency)]
weekday_bus_trips <- merge(all_trips, weekday_service, by = c("service_id", "agency"))
weekday_bus_trips <- weekday_bus_trips[unique_route_id %in% bus_routes$unique_route_id]

# Keep direction_id if available
if ("direction_id" %in% names(weekday_bus_trips)) {
  weekday_bus_trips_select <- weekday_bus_trips[, .(unique_trip_id, unique_route_id, direction_id, agency)]
} else {
  weekday_bus_trips_select <- weekday_bus_trips[, .(unique_trip_id, unique_route_id, agency)]
  weekday_bus_trips_select[, direction_id := NA_integer_]
}

# Define peak hours (Split AM and PM: 2 hours each = 120 minutes)
morning_peak_start <- as.ITime("07:00:00")
morning_peak_end <- as.ITime("09:00:00")
evening_peak_start <- as.ITime("16:00:00")
evening_peak_end <- as.ITime("18:00:00")

# Process stop times for peak hours
# GTFS allows times > 24:00:00 for trips continuing past midnight
# We need to filter these out to only get actual peak hours in Central Time
all_stop_times[, arrival_time_hhmmss := substr(arrival_time, 1, 8)]

# Extract hour component to filter out times >= 24:00:00
all_stop_times[, arrival_hour := as.integer(substr(arrival_time, 1, 2))]

# Only process times < 24 hours (same-day service in Central Time)
all_stop_times_same_day <- all_stop_times[arrival_hour < 24]
all_stop_times_same_day[, arrival_time_obj := as.ITime(arrival_time_hhmmss, format="%H:%M:%S")]

# Split into AM and PM separately (now guaranteed to be Central Time same-day)
am_stop_times <- all_stop_times_same_day[
  arrival_time_obj >= morning_peak_start & arrival_time_obj <= morning_peak_end
]
pm_stop_times <- all_stop_times_same_day[
  arrival_time_obj >= evening_peak_start & arrival_time_obj <= evening_peak_end
]

# Merge with bus trips to get AM peak bus stops
# Note: am_stop_times already has unique_route_id from all_stop_times
# We only need to add direction_id if available
if ("direction_id" %in% names(weekday_bus_trips_select)) {
  am_peak_bus_stops <- merge(
    am_stop_times,
    weekday_bus_trips_select[, .(unique_trip_id, direction_id, agency)],
    by = c("unique_trip_id", "agency")
  )
} else {
  am_peak_bus_stops <- am_stop_times
  am_peak_bus_stops[, direction_id := NA_integer_]
}

# Merge with bus trips to get PM peak bus stops
if ("direction_id" %in% names(weekday_bus_trips_select)) {
  pm_peak_bus_stops <- merge(
    pm_stop_times,
    weekday_bus_trips_select[, .(unique_trip_id, direction_id, agency)],
    by = c("unique_trip_id", "agency")
  )
} else {
  pm_peak_bus_stops <- pm_stop_times
  pm_peak_bus_stops[, direction_id := NA_integer_]
}

# Filter to only bus trips
am_peak_bus_stops <- am_peak_bus_stops[unique_trip_id %in% weekday_bus_trips_select$unique_trip_id]
pm_peak_bus_stops <- pm_peak_bus_stops[unique_trip_id %in% weekday_bus_trips_select$unique_trip_id]

# Get bus stops that need clustering
bus_stops_for_clustering <- all_stops[
  unique_stop_id %in% c(am_peak_bus_stops$unique_stop_id, pm_peak_bus_stops$unique_stop_id)
]

# Apply spatial clustering (150 ft radius)
cat("Clustering bus stops (150 ft radius)...\n")
bus_stops_clustered <- cluster_stops_spatial(bus_stops_for_clustering, cluster_radius_ft = 150)
cat(sprintf("Created %d clusters from %d bus stops\n",
            uniqueN(bus_stops_clustered$cluster_id),
            nrow(bus_stops_clustered)))

# Add cluster_id to stop times
am_peak_bus_stops <- merge(
  am_peak_bus_stops,
  bus_stops_clustered[, .(unique_stop_id, cluster_id)],
  by = "unique_stop_id"
)
pm_peak_bus_stops <- merge(
  pm_peak_bus_stops,
  bus_stops_clustered[, .(unique_stop_id, cluster_id)],
  by = "unique_stop_id"
)

# Group by cluster + direction (if available)
has_direction <- "direction_id" %in% names(am_peak_bus_stops) &&
                 sum(!is.na(am_peak_bus_stops$direction_id)) > 0

if (has_direction) {
  grouping_cols <- c("cluster_id", "direction_id", "agency")
} else {
  grouping_cols <- c("cluster_id", "agency")
}

# Calculate AM peak metrics
am_routes_at_cluster <- am_peak_bus_stops[, .(
  num_routes_am = uniqueN(unique_route_id)
), by = grouping_cols]

am_trips_at_cluster <- am_peak_bus_stops[, .(
  trips_am = .N
), by = grouping_cols]

am_metrics <- merge(am_routes_at_cluster, am_trips_at_cluster, by = grouping_cols)
am_metrics[, interval_am := 120 / trips_am]  # 120 minutes / trips

# Calculate PM peak metrics
pm_routes_at_cluster <- pm_peak_bus_stops[, .(
  num_routes_pm = uniqueN(unique_route_id)
), by = grouping_cols]

pm_trips_at_cluster <- pm_peak_bus_stops[, .(
  trips_pm = .N
), by = grouping_cols]

pm_metrics <- merge(pm_routes_at_cluster, pm_trips_at_cluster, by = grouping_cols)
pm_metrics[, interval_pm := 120 / trips_pm]  # 120 minutes / trips

# Combine AM and PM metrics
all_peak_metrics <- merge(
  am_metrics,
  pm_metrics,
  by = grouping_cols,
  all = TRUE
)

# Fill NAs (if a cluster only has AM or PM service)
all_peak_metrics[is.na(num_routes_am), num_routes_am := 0]
all_peak_metrics[is.na(num_routes_pm), num_routes_pm := 0]
all_peak_metrics[is.na(trips_am), trips_am := 0]
all_peak_metrics[is.na(trips_pm), trips_pm := 0]
all_peak_metrics[is.na(interval_am), interval_am := Inf]
all_peak_metrics[is.na(interval_pm), interval_pm := Inf]

# Calculate combined metrics (for comparison)
all_peak_metrics[, num_routes_total := pmax(num_routes_am, num_routes_pm)]
all_peak_metrics[, trips_total := trips_am + trips_pm]
all_peak_metrics[, interval_combined := 240 / trips_total]  # 240 min / total trips

# Apply hub qualification logic:
# 1. Must have 2+ routes in at least one peak period
# 2. Combined frequency <= 15 minutes in EITHER AM or PM
all_peak_metrics[, qualifies_routes := num_routes_am >= 2 | num_routes_pm >= 2]
all_peak_metrics[, qualifies_frequency := interval_am <= 15 | interval_pm <= 15]
all_peak_metrics[, qualifies_hub := qualifies_routes & qualifies_frequency]

qualifying_clusters <- all_peak_metrics[qualifies_hub == TRUE]

cat(sprintf("Found %d qualifying bus hub clusters (before overlap verification)\n", nrow(qualifying_clusters)))

# Verify that routes at each cluster actually overlap on the same street/intersection
# Combine AM and PM peak stop times for overlap analysis
all_peak_bus_stops <- rbindlist(list(am_peak_bus_stops, pm_peak_bus_stops))

# Run overlap verification for clusters that passed initial qualification
cat("Verifying route overlap at qualifying clusters...\n")
cluster_overlap_results <- verify_route_overlap_at_cluster(
  cluster_stops_dt = bus_stops_clustered[cluster_id %in% qualifying_clusters$cluster_id],
  stop_times_dt = all_peak_bus_stops[cluster_id %in% qualifying_clusters$cluster_id]
)

# Filter to only clusters where routes actually overlap
qualifying_clusters <- merge(
  qualifying_clusters,
  cluster_overlap_results[, .(cluster_id, has_overlap, shared_streets)],
  by = "cluster_id"
)

qualifying_clusters <- qualifying_clusters[has_overlap == TRUE]

cat(sprintf("Found %d qualifying bus hub clusters (after overlap verification)\n", nrow(qualifying_clusters)))

# Map clusters back to individual stops
qualifying_stop_ids <- bus_stops_clustered[
  cluster_id %in% qualifying_clusters$cluster_id,
  .(unique_stop_id, cluster_id, agency, stop_id, stop_name, stop_lat, stop_lon)
]

# Add metrics to stops (merge on cluster + direction if applicable)
if (has_direction) {
  # For direction-aware analysis, need to join trips data to get direction per stop
  stop_directions <- unique(rbind(
    am_peak_bus_stops[, .(unique_stop_id, direction_id)],
    pm_peak_bus_stops[, .(unique_stop_id, direction_id)]
  ))

  qualifying_stop_ids <- merge(
    qualifying_stop_ids,
    stop_directions,
    by = "unique_stop_id",
    allow.cartesian = TRUE
  )

  qualifying_stop_ids <- merge(
    qualifying_stop_ids,
    qualifying_clusters,
    by = c("cluster_id", "direction_id", "agency"),
    all.x = TRUE
  )
} else {
  qualifying_stop_ids <- merge(
    qualifying_stop_ids,
    qualifying_clusters,
    by = c("cluster_id", "agency"),
    all.x = TRUE
  )
}

# Calculate first and last departure times for each qualifying cluster
# Times are in Central Time (GTFS local time for Chicago area)
# Helper function to convert ITime to 12-hour format string
format_itime <- function(itime_obj) {
  # ITime stores seconds since midnight
  # Convert to hours and minutes
  hours <- itime_obj %/% 3600
  minutes <- (itime_obj %% 3600) %/% 60

  # Convert to 12-hour format
  period <- ifelse(hours < 12, "AM", "PM")
  display_hours <- ifelse(hours == 0, 12, ifelse(hours > 12, hours - 12, hours))

  sprintf("%02d:%02d %s", display_hours, minutes, period)
}

# AM peak departure times (7-9 AM Central)
am_cluster_times <- am_peak_bus_stops[cluster_id %in% qualifying_clusters$cluster_id, .(
  first_departure_am = format_itime(min(arrival_time_obj)),
  last_departure_am = format_itime(max(arrival_time_obj))
), by = cluster_id]

# PM peak departure times (4-6 PM Central)
pm_cluster_times <- pm_peak_bus_stops[cluster_id %in% qualifying_clusters$cluster_id, .(
  first_departure_pm = format_itime(min(arrival_time_obj)),
  last_departure_pm = format_itime(max(arrival_time_obj))
), by = cluster_id]

# Calculate route lists and directions for each cluster
# Get unique routes serving each cluster
cluster_routes <- all_peak_bus_stops[cluster_id %in% qualifying_clusters$cluster_id, {
  # Get unique route IDs
  route_ids <- unique(unique_route_id)

  # Extract route short names by merging with all_routes
  route_info <- all_routes[unique_route_id %in% route_ids,
                           .(unique_route_id, route_short_name, route_long_name)]

  # Create route display names (use short name if available, else use long name)
  route_names <- if (nrow(route_info) > 0) {
    sapply(route_info$unique_route_id, function(rid) {
      r <- route_info[unique_route_id == rid]
      if (!is.na(r$route_short_name) && r$route_short_name != "") {
        r$route_short_name
      } else if (!is.na(r$route_long_name)) {
        r$route_long_name
      } else {
        gsub("^[^_]+_", "", rid)  # Extract route ID from unique_route_id
      }
    })
  } else {
    sapply(route_ids, function(rid) gsub("^[^_]+_", "", rid))
  }

  routes_list <- paste(sort(unique(route_names)), collapse = ", ")

  # Get directions if available
  if ("direction_id" %in% names(.SD) && sum(!is.na(direction_id)) > 0) {
    directions <- unique(direction_id[!is.na(direction_id)])
    direction_labels <- sapply(directions, function(d) {
      if (d == 0) "Outbound" else if (d == 1) "Inbound" else as.character(d)
    })
    directions_list <- paste(sort(direction_labels), collapse = ", ")
  } else {
    directions_list <- "N/A"
  }

  list(routes = routes_list, directions = directions_list)
}, by = cluster_id]

# Merge departure times with qualifying_stop_ids
qualifying_stop_ids <- merge(
  qualifying_stop_ids,
  am_cluster_times,
  by = "cluster_id",
  all.x = TRUE
)

qualifying_stop_ids <- merge(
  qualifying_stop_ids,
  pm_cluster_times,
  by = "cluster_id",
  all.x = TRUE
)

qualifying_stop_ids <- merge(
  qualifying_stop_ids,
  cluster_routes,
  by = "cluster_id",
  all.x = TRUE
)

qualifying_bus_hubs <- qualifying_stop_ids[, .(
  unique_stop_id, stop_id, stop_name, stop_lat, stop_lon, agency,
  cluster_id, num_routes_am, num_routes_pm, num_routes_total,
  trips_am, trips_pm, trips_total,
  interval_am, interval_pm, interval_combined,
  first_departure_am, last_departure_am,
  first_departure_pm, last_departure_pm,
  routes, directions
)]
qualifying_bus_hubs[, type := "bus_hub"]


# --- Combine All Hubs ---

all_hubs <- rbindlist(list(rail_stops, qualifying_bus_hubs), fill = TRUE)

# Create a spatial object for all hubs
all_hubs_sf <- st_as_sf(all_hubs, coords = c("stop_lon", "stop_lat"), crs = 4326)

# Add agency information
all_hubs_sf$agency_name <- factor(
  all_hubs_sf$agency,
  levels = c("cta", "pace", "metra", "metro_stl", "cumtd"),
  labels = c("CTA", "Pace", "Metra", "Metro STL", "MTD")
)
```

```{r process_corridors_and_buffers, results='hide'}
## Identify Corridors and Create Buffers (UPDATED)

# --- Identify Qualifying Corridors ---

# Corridors: "one or more bus routes" with combined frequency <= 15 minutes
# Apply same AM/PM split logic, qualify if EITHER period meets threshold

# 1. Calculate AM peak frequency at all bus stops (no clustering for corridors)
am_corridor_trips <- am_peak_bus_stops[, .(
  trips_am = .N,
  num_routes_am = uniqueN(unique_route_id)
), by = .(unique_stop_id, agency)]
am_corridor_trips[, interval_am := 120 / trips_am]

# 2. Calculate PM peak frequency at all bus stops
pm_corridor_trips <- pm_peak_bus_stops[, .(
  trips_pm = .N,
  num_routes_pm = uniqueN(unique_route_id)
), by = .(unique_stop_id, agency)]
pm_corridor_trips[, interval_pm := 120 / trips_pm]

# 3. Combine AM and PM metrics
all_corridor_metrics <- merge(
  am_corridor_trips,
  pm_corridor_trips,
  by = c("unique_stop_id", "agency"),
  all = TRUE
)

# Fill NAs
all_corridor_metrics[is.na(num_routes_am), num_routes_am := 0]
all_corridor_metrics[is.na(num_routes_pm), num_routes_pm := 0]
all_corridor_metrics[is.na(trips_am), trips_am := 0]
all_corridor_metrics[is.na(trips_pm), trips_pm := 0]
all_corridor_metrics[is.na(interval_am), interval_am := Inf]
all_corridor_metrics[is.na(interval_pm), interval_pm := Inf]

# Calculate combined metrics
all_corridor_metrics[, trips_total := trips_am + trips_pm]
all_corridor_metrics[, interval_combined := 240 / trips_total]

# 4. Qualify corridors: frequency <= 15 in EITHER AM or PM
# (No minimum route requirement for corridors - "one or more" routes)
all_corridor_metrics[, qualifies_corridor := interval_am <= 15 | interval_pm <= 15]

qualifying_corridor_stops_data <- all_corridor_metrics[qualifies_corridor == TRUE]

cat(sprintf("Found %d qualifying corridor stops\n", nrow(qualifying_corridor_stops_data)))

# 5. Get geometry for these qualifying stops
qualifying_corridor_stops <- merge(
  all_stops,
  qualifying_corridor_stops_data,
  by = c("unique_stop_id", "agency")
)

qualifying_corridor_stops_sf <- st_as_sf(
  qualifying_corridor_stops,
  coords = c("stop_lon", "stop_lat"),
  crs = 4326
)

# 6. Get Street Network Data (TIGRIS) for Illinois counties
# Chicago area - 6 counties: Cook (031), DuPage (043), Kane (089), Lake (097), McHenry (111), Will (197)
# St. Louis area - IL counties: St. Clair (163), Madison (119), Monroe (133)
# Champaign-Urbana area: Champaign County (019)
# Using FIPS codes instead of names to avoid "Invalid county" error
counties_fips <- c("031", "043", "089", "097", "111", "197",  # Chicago metro
                   "163", "119", "133",                        # St. Louis metro (IL side)
                   "019")                                      # Champaign-Urbana

# Download roads for all counties and combine
all_streets_sf <- rbindlist(lapply(counties_fips, function(co) {
  roads(state = "IL", county = co, year = 2023)
})) %>% st_as_sf()

# Project streets to IL State Plane (feet) for buffering and snapping
all_streets_projected <- st_transform(all_streets_sf, 3435)

# 7. Snap qualifying stops to nearest street segment
qualifying_stops_projected <- st_transform(qualifying_corridor_stops_sf, 3435)

# Find the index of the nearest street for each stop
nearest_street_index <- st_nearest_feature(qualifying_stops_projected, all_streets_projected)

# Get the unique IDs (LINEARID) of the qualifying street segments
qualifying_street_ids <- unique(all_streets_projected$LINEARID[nearest_street_index])

# 8. Select the qualifying street segments
qualifying_corridors_projected <- all_streets_projected[all_streets_projected$LINEARID %in% qualifying_street_ids, ]


# --- Create Buffers ---

# 1. Buffer Corridors (1/8 mile = 660 feet)
corridor_buffers_projected <- st_buffer(qualifying_corridors_projected, 660)
all_corridors_union <- st_union(corridor_buffers_projected)

# 2. Buffer Hubs (1/2 mile = 2640 feet)
all_hubs_projected <- st_transform(all_hubs_sf, 3435)
half_mile_buffers <- st_buffer(all_hubs_projected, 2640)
all_hub_areas <- st_union(half_mile_buffers)

# --- Combine Areas and Transform back to WGS84 ---

# Corridors - transform and clip to Illinois boundary
all_corridors_union_wgs84_raw <- st_transform(all_corridors_union, 4326)
all_corridors_union_wgs84 <- st_intersection(all_corridors_union_wgs84_raw, illinois_boundary)

# Hubs
all_hub_areas_wgs84 <- st_transform(all_hub_areas, 4326)
half_mile_buffers_wgs84 <- st_transform(half_mile_buffers, 4326)

# Separate hub buffers by agency
cta_hub_buffers <- half_mile_buffers_wgs84[half_mile_buffers_wgs84$agency == "cta", ]
pace_hub_buffers <- half_mile_buffers_wgs84[half_mile_buffers_wgs84$agency == "pace", ]
metra_hub_buffers <- half_mile_buffers_wgs84[half_mile_buffers_wgs84$agency == "metra", ]
metro_stl_hub_buffers <- half_mile_buffers_wgs84[half_mile_buffers_wgs84$agency == "metro_stl", ]
cumtd_hub_buffers <- half_mile_buffers_wgs84[half_mile_buffers_wgs84$agency == "cumtd", ]

# Union hub buffers by agency and clip to Illinois boundary
cta_hubs_union <- if(nrow(cta_hub_buffers) > 0) st_intersection(st_union(cta_hub_buffers), illinois_boundary) else st_sfc(crs = 4326)
pace_hubs_union <- if(nrow(pace_hub_buffers) > 0) st_intersection(st_union(pace_hub_buffers), illinois_boundary) else st_sfc(crs = 4326)
metra_hubs_union <- if(nrow(metra_hub_buffers) > 0) st_intersection(st_union(metra_hub_buffers), illinois_boundary) else st_sfc(crs = 4326)
metro_stl_hubs_union <- if(nrow(metro_stl_hub_buffers) > 0) st_intersection(st_union(metro_stl_hub_buffers), illinois_boundary) else st_sfc(crs = 4326)
cumtd_hubs_union <- if(nrow(cumtd_hub_buffers) > 0) st_intersection(st_union(cumtd_hub_buffers), illinois_boundary) else st_sfc(crs = 4326)

# Separate corridor buffers by agency (approximate)
# This is more complex, as a street can be served by multiple agencies.
# For simplicity, we'll just show the combined corridor buffer.
# A more advanced analysis would attribute segments to agencies.
# We will create an 'all_corridors_union_wgs84' object for the map.

# Combine all affected areas (hubs + corridors)
all_affected_areas_combined_raw <- st_union(c(all_hub_areas_wgs84, all_corridors_union_wgs84))

# Clip to Illinois boundary to exclude Missouri areas
all_affected_areas_combined <- st_intersection(all_affected_areas_combined_raw, illinois_boundary)
```

```{r calculate_areas}
## Calculate Areas

# Calculate areas in square miles
hub_area_sqft <- st_area(all_hub_areas_wgs84)
hub_area_sqmi <- units::set_units(hub_area_sqft, "mi^2")

corridor_area_sqft <- st_area(all_corridors_union_wgs84)
corridor_area_sqmi <- units::set_units(corridor_area_sqft, "mi^2")

combined_area_sqft <- st_area(all_affected_areas_combined)
combined_area_sqmi <- units::set_units(combined_area_sqft, "mi^2")

# Total area covered by analysis
# Chicago MSA (6 IL counties): Cook: 953.6, DuPage: 336.5, Kane: 524.2, Lake: 470, McHenry: 611, Will: 849.2
# St. Louis MSA (3 IL counties): St. Clair: 674.6, Madison: 741.5, Monroe: 398.2
# Champaign-Urbana: Champaign County: 1,008
chicago_il_msa_area_sqmi <- 953.6 + 336.5 + 524.2 + 470 + 611 + 849.2
stlouis_il_msa_area_sqmi <- 674.6 + 741.5 + 398.2
champaign_area_sqmi <- 1008
total_il_area_sqmi <- chicago_il_msa_area_sqmi + stlouis_il_msa_area_sqmi + champaign_area_sqmi

# Calculate percentages (against total IL area covered)
pct_hubs <- as.numeric(hub_area_sqmi) / total_il_area_sqmi * 100
pct_corridors <- as.numeric(corridor_area_sqmi) / total_il_area_sqmi * 100
pct_combined <- as.numeric(combined_area_sqmi) / total_il_area_sqmi * 100

# Count hubs and routes
hub_counts <- table(all_hubs_sf$agency_name)
qualifying_corridor_stop_count <- nrow(qualifying_corridor_stops_sf)
```

## Interactive Map: Areas Affected by the Updated People Over Parking Act

```{r create_map}
# Define color palettes
agency_pal <- colorFactor(
  palette = c("#009CDE", "#814C9E", "#E31837", "#00A651", "#FF6600"),  # CTA blue, Pace purple, Metra red, Metro STL green, MTD orange
  domain = all_hubs_sf$agency_name
)

# Create the interactive map
map <- leaflet() %>%
  setView(lng = -87.6079, lat = 41.8917, zoom = 9) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Combined affected areas (default visible)
  addPolygons(
    data = all_affected_areas_combined,
    fillColor = "purple",
    fillOpacity = 0.25,
    weight = 1,
    color = "purple",
    opacity = 0.7,
    group = "All Affected Areas (Hubs + Corridors)"
  ) %>%
  
  # Hub areas by agency
  addPolygons(
    data = cta_hubs_union,
    fillColor = "#009CDE",
    fillOpacity = 0.4,
    weight = 1,
    color = "#009CDE",
    opacity = 0.8,
    group = "CTA Hubs (1/2 mile)"
  ) %>%
  addPolygons(
    data = pace_hubs_union,
    fillColor = "#814C9E",
    fillOpacity = 0.4,
    weight = 1,
    color = "#814C9E",
    opacity = 0.8,
    group = "Pace Hubs (1/2 mile)"
  ) %>%
  addPolygons(
    data = metra_hubs_union,
    fillColor = "#E31837",
    fillOpacity = 0.4,
    weight = 1,
    color = "#E31837",
    opacity = 0.8,
    group = "Metra Hubs (1/2 mile)"
  ) %>%
  addPolygons(
    data = metro_stl_hubs_union,
    fillColor = "#00A651",
    fillOpacity = 0.4,
    weight = 1,
    color = "#00A651",
    opacity = 0.8,
    group = "Metro STL Hubs (1/2 mile)"
  ) %>%
  addPolygons(
    data = cumtd_hubs_union,
    fillColor = "#FF6600",
    fillOpacity = 0.4,
    weight = 1,
    color = "#FF6600",
    opacity = 0.8,
    group = "MTD Hubs (1/2 mile)"
  ) %>%

  # Corridor areas (combined)
  addPolygons(
    data = all_corridors_union_wgs84,
    fillColor = "#FF8C00", # Orange for corridors
    fillOpacity = 0.3,
    weight = 1,
    color = "#FF8C00",
    opacity = 0.6,
    group = "All Corridors (1/8 mile)",
    dashArray = "5,5"
  ) %>%
  
  # Hub points
  addCircleMarkers(
    data = all_hubs_sf,
    radius = 3,
    color = ~agency_pal(agency_name),
    stroke = FALSE,
    fillOpacity = 0.8,
    group = "Transit Hub Points",
    popup = ~paste0(
      "<strong>", stop_name, "</strong><br>",
      "Agency: ", agency_name, "<br>",
      "Type: ", type, "<br>",
      "Stop ID: ", stop_id, "<br>",
      # Add diagnostic info for bus hubs
      if_else(type == "bus_hub" & !is.na(num_routes_total),
        paste0(
          "<hr>",
          "<strong>Cluster ID: ", cluster_id, "</strong><br>",
          "<hr>",
          "<strong>Routes:</strong> ", if_else(!is.na(routes), routes, "N/A"), "<br>",
          "<strong>Directions:</strong> ", if_else(!is.na(directions), directions, "N/A"), "<br>",
          "<hr>",
          "<strong>Service Frequency:</strong><br>",
          "Routes (AM/PM/Total): ", num_routes_am, "/", num_routes_pm, "/", num_routes_total, "<br>",
          "Trips (AM/PM/Total): ", trips_am, "/", trips_pm, "/", trips_total, "<br>",
          "Avg Interval (AM/PM): ", round(interval_am, 1), "/", round(interval_pm, 1), " min<br>",
          "Combined Interval: ", round(interval_combined, 1), " min<br>",
          "<hr>",
          "<strong>AM Peak Service (7-9 AM Central):</strong><br>",
          "First Departure: ", if_else(!is.na(first_departure_am), first_departure_am, "N/A"), "<br>",
          "Last Departure: ", if_else(!is.na(last_departure_am), last_departure_am, "N/A"), "<br>",
          "<hr>",
          "<strong>PM Peak Service (4-6 PM Central):</strong><br>",
          "First Departure: ", if_else(!is.na(first_departure_pm), first_departure_pm, "N/A"), "<br>",
          "Last Departure: ", if_else(!is.na(last_departure_pm), last_departure_pm, "N/A")
        ),
        ""
      )
    )
  ) %>%
  
  # Layer controls
  addLayersControl(
    baseGroups = c("CartoDB.Positron"),
    overlayGroups = c(
      "All Affected Areas (Hubs + Corridors)",
      "CTA Hubs (1/2 mile)",
      "Pace Hubs (1/2 mile)",
      "Metra Hubs (1/2 mile)",
      "Metro STL Hubs (1/2 mile)",
      "MTD Hubs (1/2 mile)",
      "All Corridors (1/8 mile)",
      "Transit Hub Points"
    ),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%

  # Hide individual layers by default, show only combined
  hideGroup(c(
    "CTA Hubs (1/2 mile)",
    "Pace Hubs (1/2 mile)",
    "Metra Hubs (1/2 mile)",
    "Metro STL Hubs (1/2 mile)",
    "MTD Hubs (1/2 mile)",
    "All Corridors (1/8 mile)",
    "Transit Hub Points"
  )) %>%
  
  # Add legend
  addLegend(
    position = "bottomright",
    colors = c("purple", "#009CDE", "#814C9E", "#E31837", "#00A651", "#FF6600", "#FF8C00"),
    labels = c("All Affected Areas",
               "CTA Hubs",
               "Pace Hubs",
               "Metra Hubs",
               "Metro STL Hubs",
               "MTD Hubs",
               "All Corridors (dashed)"),
    opacity = 0.7
  ) %>%
  
  addFullscreenControl() %>%
  addMeasure(
    position = "bottomleft",
    primaryLengthUnit = "miles",
    primaryAreaUnit = "sqmiles",
    activeColor = "#3D535D",
    completedColor = "#7D4479"
  )

# Display the map
map
```

This analysis examines the potential impact of new legislation passed in Illinois (SB2111) on Chicagoland.

According to the updated bill [10400SB2111ham003](https://www.ilga.gov/documents/legislation/104/SB/PDF/10400SB2111ham003.pdf), minimum parking requirements are prohibited for development projects located within:

- **1/2 mile of public transportation hubs**, defined as:
  - (i) A rail transit station
  - (ii) A boat or ferry terminal served by either a bus connection stop or rail transit station
  - (iii) An intersection of 2 or more bus routes with a **combined frequency** of service interval of 15 minutes or less during peak commute periods

- **1/8 mile of public transportation corridors**, defined as:
  - A street on which there is **one or more bus routes** with a **combined frequency** of bus service interval of 15 minutes or less during the morning and afternoon peak commute periods

### Analysis Methodology

This analysis implements the following methodology to identify qualifying transit hubs and corridors:

**Peak Period Definition:**

- Morning peak: 7:00 AM - 9:00 AM (120 minutes)
- Afternoon peak: 4:00 PM - 6:00 PM (120 minutes)
- Service is analyzed separately for each period; locations qualify if they meet frequency thresholds in **either** AM **or** PM

**Stop Clustering (Bus Hubs Only):**

- Bus stops within **150 feet** of each other are spatially clustered to represent physical intersections
- This prevents overcounting stops at the same street corner and aligns with the statutory concept of "an intersection of 2 or more bus routes"
- Clustering uses Illinois State Plane East projection (EPSG:3435) for accurate distance measurement

**Route Overlap Verification (Bus Hubs Only):**

- After clustering, we verify that routes actually overlap at the same physical intersection or street
- Stop names (e.g., "Jackson & Lotus", "Oak Ave & Davis St") are parsed to extract street names
- A cluster qualifies only if **2 or more routes share at least one common street name**
- This ensures routes truly intersect at the location, not just have nearby stops within 150 feet
- Example: Route A stops at "State & Madison", Route B stops at "State & Monroe" (both within 150ft) → they share "State" street → overlap verified

**Combined Frequency Calculation:**

- For each stop cluster (hubs) or individual stop (corridors), we count total trips across all routes during each peak period
- Combined service interval = peak period duration (120 min) ÷ total trips
- Example: 8 trips in 2 hours = 120 ÷ 8 = **15 minute average interval**

**Qualification Criteria:**

- **Bus Hubs**: Must have **2 or more routes** AND **combined frequency ≤ 15 minutes** in at least one peak period AND **routes must overlap on same street/intersection**
- **Bus Corridors**: Must have **1 or more routes** AND **combined frequency ≤ 15 minutes** in at least one peak period
- **Rail Hubs**: All rail stations within Illinois automatically qualify (CTA rail, Metra, and Metro St. Louis MetroLink)

**Direction Handling:**

- If GTFS `direction_id` data is available, routes are analyzed by direction (northbound/southbound, eastbound/westbound)
- This provides more accurate service frequency calculations at directional stops

**Geographic Boundaries and Clipping:**

- All transit hub and corridor buffers are clipped to Illinois state boundaries
- This ensures parking mandate relief applies only to areas within Illinois jurisdiction
- Metro St. Louis transit system operates across the Illinois-Missouri border; only Illinois portions of hub/corridor buffers are included in the analysis
- Metra serves some stations in Wisconsin (Kenosha County); these are excluded from the analysis (latitude filter at 42.5°)
- Clipping is performed after buffer creation using the U.S. Census TIGER/Line state boundary for Illinois

**Data Sources:**

- Chicago area: CTA, Pace, and Metra GTFS (General Transit Feed Specification) data
- St. Louis area: Metro St. Louis GTFS data (includes MetroLink light rail and MetroBus)
  - Note: Metro St. Louis operates in both Missouri and Illinois; only Illinois portions are included after geographic clipping
- Champaign-Urbana: CUMTD (Champaign-Urbana Mass Transit District) GTFS data
- TIGER/Line street network data from U.S. Census Bureau via tigris package
- Analysis covers 10 Illinois counties:
  - Chicago metro: Cook, DuPage, Kane, Lake, McHenry, and Will
  - St. Louis metro: St. Clair, Madison, and Monroe
  - Champaign-Urbana: Champaign



```{r summary_stats, include=FALSE}
# Calculate all summary statistics and store in variables

# Bus hub summary
bus_hub_summary <- qualifying_bus_hubs[, .(
  total_stops = .N,
  unique_clusters = uniqueN(cluster_id),
  avg_routes_am = mean(num_routes_am, na.rm = TRUE),
  avg_routes_pm = mean(num_routes_pm, na.rm = TRUE),
  avg_interval_am = mean(interval_am[is.finite(interval_am)], na.rm = TRUE),
  avg_interval_pm = mean(interval_pm[is.finite(interval_pm)], na.rm = TRUE)
), by = agency]

# Corridor summary
corridor_summary <- qualifying_corridor_stops[, .(
  total_stops = .N,
  avg_routes_am = mean(num_routes_am, na.rm = TRUE),
  avg_routes_pm = mean(num_routes_pm, na.rm = TRUE),
  avg_interval_am = mean(interval_am[is.finite(interval_am)], na.rm = TRUE),
  avg_interval_pm = mean(interval_pm[is.finite(interval_pm)], na.rm = TRUE)
), by = agency]

# Count rail hubs
rail_hub_count <- nrow(rail_stops)
total_hubs <- nrow(all_hubs_sf)

# Extract agency-specific stats
cta_hub <- bus_hub_summary[agency == "cta"]
pace_hub <- bus_hub_summary[agency == "pace"]
metro_stl_hub <- bus_hub_summary[agency == "metro_stl"]
cumtd_hub <- bus_hub_summary[agency == "cumtd"]
cta_corridor <- corridor_summary[agency == "cta"]
pace_corridor <- corridor_summary[agency == "pace"]
metro_stl_corridor <- corridor_summary[agency == "metro_stl"]
cumtd_corridor <- corridor_summary[agency == "cumtd"]

# Count rail hubs by agency
rail_hub_counts <- table(rail_stops$agency)
```

## Summary Statistics

### Bus Transit Hubs

**Methodology:** Stops clustered at 150 ft radius; qualifies if 2+ routes AND combined frequency ≤15 min in EITHER AM (7-9am) or PM (4-6pm) peak period.

**CTA:**

- Bus hub stops: **`r cta_hub$total_stops`** (in `r cta_hub$unique_clusters` clusters)
- Average routes per cluster: **`r sprintf("%.1f", cta_hub$avg_routes_am)` (AM)** / **`r sprintf("%.1f", cta_hub$avg_routes_pm)` (PM)**
- Average service interval: **`r sprintf("%.1f", cta_hub$avg_interval_am)` min (AM)** / **`r sprintf("%.1f", cta_hub$avg_interval_pm)` min (PM)**

**Pace:**

- Bus hub stops: **`r pace_hub$total_stops`** (in `r pace_hub$unique_clusters` clusters)
- Average routes per cluster: **`r sprintf("%.1f", pace_hub$avg_routes_am)` (AM)** / **`r sprintf("%.1f", pace_hub$avg_routes_pm)` (PM)**
- Average service interval: **`r sprintf("%.1f", pace_hub$avg_interval_am)` min (AM)** / **`r sprintf("%.1f", pace_hub$avg_interval_pm)` min (PM)**

**Metro St. Louis:**

- Bus hub stops: **`r if(nrow(metro_stl_hub) > 0) metro_stl_hub$total_stops else 0`** (in `r if(nrow(metro_stl_hub) > 0) metro_stl_hub$unique_clusters else 0` clusters)
- Average routes per cluster: **`r if(nrow(metro_stl_hub) > 0) sprintf("%.1f", metro_stl_hub$avg_routes_am) else "N/A"` (AM)** / **`r if(nrow(metro_stl_hub) > 0) sprintf("%.1f", metro_stl_hub$avg_routes_pm) else "N/A"` (PM)**
- Average service interval: **`r if(nrow(metro_stl_hub) > 0) sprintf("%.1f", metro_stl_hub$avg_interval_am) else "N/A"` min (AM)** / **`r if(nrow(metro_stl_hub) > 0) sprintf("%.1f", metro_stl_hub$avg_interval_pm) else "N/A"` min (PM)**

**Champaign-Urbana MTD:**

- Bus hub stops: **`r if(nrow(cumtd_hub) > 0) cumtd_hub$total_stops else 0`** (in `r if(nrow(cumtd_hub) > 0) cumtd_hub$unique_clusters else 0` clusters)
- Average routes per cluster: **`r if(nrow(cumtd_hub) > 0) sprintf("%.1f", cumtd_hub$avg_routes_am) else "N/A"` (AM)** / **`r if(nrow(cumtd_hub) > 0) sprintf("%.1f", cumtd_hub$avg_routes_pm) else "N/A"` (PM)**
- Average service interval: **`r if(nrow(cumtd_hub) > 0) sprintf("%.1f", cumtd_hub$avg_interval_am) else "N/A"` min (AM)** / **`r if(nrow(cumtd_hub) > 0) sprintf("%.1f", cumtd_hub$avg_interval_pm) else "N/A"` min (PM)**

**Rail Stations:** `r rail_hub_count`
- CTA: `r if("cta" %in% names(rail_hub_counts)) rail_hub_counts["cta"] else 0`
- Metra: `r if("metra" %in% names(rail_hub_counts)) rail_hub_counts["metra"] else 0`
- Metro STL: `r if("metro_stl" %in% names(rail_hub_counts)) rail_hub_counts["metro_stl"] else 0`

**Total Transit Hubs:** `r formatC(total_hubs, format="d", big.mark=",")`

### Bus Corridors

**Methodology:** Individual stops (no clustering); qualifies if combined frequency ≤15 min in EITHER AM (7-9am) or PM (4-6pm) peak period.

**CTA:**

- Corridor stops: **`r formatC(cta_corridor$total_stops, format="d", big.mark=",")`**
- Average routes per stop: **`r sprintf("%.1f", cta_corridor$avg_routes_am)` (AM)** / **`r sprintf("%.1f", cta_corridor$avg_routes_pm)` (PM)**
- Average service interval: **`r sprintf("%.1f", cta_corridor$avg_interval_am)` min (AM)** / **`r sprintf("%.1f", cta_corridor$avg_interval_pm)` min (PM)**

**Pace:**

- Corridor stops: **`r formatC(pace_corridor$total_stops, format="d", big.mark=",")`**
- Average routes per stop: **`r sprintf("%.1f", pace_corridor$avg_routes_am)` (AM)** / **`r sprintf("%.1f", pace_corridor$avg_routes_pm)` (PM)**
- Average service interval: **`r sprintf("%.1f", pace_corridor$avg_interval_am)` min (AM)** / **`r sprintf("%.1f", pace_corridor$avg_interval_pm)` min (PM)**

**Metro St. Louis:**

- Corridor stops: **`r if(nrow(metro_stl_corridor) > 0) formatC(metro_stl_corridor$total_stops, format="d", big.mark=",") else "0"`**
- Average routes per stop: **`r if(nrow(metro_stl_corridor) > 0) sprintf("%.1f", metro_stl_corridor$avg_routes_am) else "N/A"` (AM)** / **`r if(nrow(metro_stl_corridor) > 0) sprintf("%.1f", metro_stl_corridor$avg_routes_pm) else "N/A"` (PM)**
- Average service interval: **`r if(nrow(metro_stl_corridor) > 0) sprintf("%.1f", metro_stl_corridor$avg_interval_am) else "N/A"` min (AM)** / **`r if(nrow(metro_stl_corridor) > 0) sprintf("%.1f", metro_stl_corridor$avg_interval_pm) else "N/A"` min (PM)**

**Champaign-Urbana MTD:**

- Corridor stops: **`r if(nrow(cumtd_corridor) > 0) formatC(cumtd_corridor$total_stops, format="d", big.mark=",") else "0"`**
- Average routes per stop: **`r if(nrow(cumtd_corridor) > 0) sprintf("%.1f", cumtd_corridor$avg_routes_am) else "N/A"` (AM)** / **`r if(nrow(cumtd_corridor) > 0) sprintf("%.1f", cumtd_corridor$avg_routes_pm) else "N/A"` (PM)**
- Average service interval: **`r if(nrow(cumtd_corridor) > 0) sprintf("%.1f", cumtd_corridor$avg_interval_am) else "N/A"` min (AM)** / **`r if(nrow(cumtd_corridor) > 0) sprintf("%.1f", cumtd_corridor$avg_interval_pm) else "N/A"` min (PM)**

### Geographic Coverage

- **Hub buffer area (1/2 mile):** `r sprintf("%.1f", as.numeric(hub_area_sqmi))` sq mi (`r sprintf("%.2f%%", pct_hubs)` of total area)
- **Corridor buffer area (1/8 mile):** `r sprintf("%.1f", as.numeric(corridor_area_sqmi))` sq mi (`r sprintf("%.2f%%", pct_corridors)` of total area)
- **Combined affected area:** `r sprintf("%.1f", as.numeric(combined_area_sqmi))` sq mi (`r sprintf("%.2f%%", pct_combined)` of total area)
- **Total Illinois area analyzed:**
  - Chicago MSA (6 counties): `r sprintf("%.1f", chicago_il_msa_area_sqmi)` sq mi
  - St. Louis MSA (3 IL counties): `r sprintf("%.1f", stlouis_il_msa_area_sqmi)` sq mi
  - Champaign-Urbana (1 county): `r sprintf("%.1f", champaign_area_sqmi)` sq mi
  - **Total: `r sprintf("%.1f", total_il_area_sqmi)` sq mi**

**Note**: Area calculations reflect only portions within Illinois state boundaries. Cross-border transit services (Metro St. Louis in Missouri, Metra in Wisconsin) are excluded through geographic clipping.

## Notes on Updated Methodology

This analysis implements the following improvements to align with SB 2111's statutory language:

1. **Split AM/PM Peak Periods**: Service is analyzed separately for morning (7-9am) and afternoon (4-6pm) peak periods, then combined using "either" logic—a location qualifies if it meets the frequency threshold in **either** AM **or** PM.

2. **Stop Clustering (Hubs Only)**: Bus stops within **150 feet** are clustered together to represent physical intersections. This prevents overcounting stops at the same intersection and better reflects the statutory concept of "an intersection of 2 or more bus routes."

3. **Direction-Aware (if available)**: If `direction_id` is present in GTFS data, the analysis accounts for directionality (northbound vs southbound) when calculating service frequency.

4. **Qualification Criteria**:
   - **Bus Hubs**: Must have **2+ routes** AND **combined frequency ≤15 minutes** in at least one peak period
   - **Bus Corridors**: Must have **1+ routes** AND **combined frequency ≤15 minutes** in at least one peak period

5. **Transparent Metrics**: Each hub and corridor stop now includes diagnostic information showing AM/PM service levels, making it easy to verify which locations qualify and why.

6. **Illinois Boundary Clipping**: All hub and corridor buffer areas are clipped to Illinois state boundaries after calculation. This is critical for cross-border transit agencies (Metro St. Louis, Metra) to ensure parking mandate relief applies only within Illinois jurisdiction. Area calculations reflect only the Illinois portions of buffer zones.
